# Financial Transaction Monitoring & Analytics Platform (Simulated FinTech System)

A full-stack fintech application that simulates core banking functionality — user authentication, account creation, balance checks, and fund transfers — built with a modular microservices architecture for clarity and extensibility.

## Table of contents

- [Project Overview](#project-overview)
- [Architecture](#architecture)
  - [Auth Service](#auth-service)
  - [Transaction Service](#transaction-service)
  - [API Gateway](#api-gateway)
  - [Frontend (React)](#frontend-react)
- [Current Features Implemented](#current-features-implemented)
- [Database Schema (high level)](#database-schema-high-level)
- [Security & State Management](#security--state-management)
- [Technologies](#technologies)
- [Getting Started](#getting-started)
  - [Prerequisites](#prerequisites)
  - [Environment variables (examples)](#environment-variables-examples)
  - [Running the services locally](#running-the-services-locally)
- [Future Plans](#future-plans)
- [Contributing](#contributing)
- [License](#license)

## Project overview

This project simulates a fintech transaction platform using a microservices approach. Services are separated by responsibility (authentication, transactions, gateway, and frontend) to model realistic service boundaries and to make the system easier to extend with services such as alerts and analytics.

## Architecture

The system follows a microservices architecture with a single API Gateway for routing.

### Auth Service
- Responsibilities:
  - User registration and login
  - User profile retrieval
  - Account number and basic user metadata generation
- Endpoints:
  - POST /register — register a new user
  - POST /login — authenticate user and create a session
  - GET /getUser — fetch the logged-in user profile
- Security:
  - Uses HTTP-only cookies for session/authentication
  - Passwords are stored hashed
  - User records persisted in the database

### Transaction Service
- Responsibilities:
  - Bank account creation and management
  - Balance checks (PIN authenticated)
  - Fund transfers between accounts (single payment gateway processing)
- Features:
  - Create bank accounts (account numbers may be generated by Auth Service)
  - Check account balance using PIN verification
  - Transfer money using account number + PIN
  - Idempotency handling to avoid duplicate transactions
  - Single payment gateway flow for transactional processing
- Database tables used (high level):
  - payment_attempts — tracks each payment attempt
  - transactions — records successful transactions
  - idempotency — ensures transaction uniqueness and safe retries

### API Gateway
- Acts as the single entry point for clients
- Routes requests to the appropriate microservice
- Does not implement business logic (routing and request forwarding only)
- Intended extension points: logging, rate limiting, monitoring

### Frontend (React)
- Pages / features:
  - Authentication (register/login/logout)
  - Dashboard: view account details and transaction history
  - Transfer Money: initiate transfers with PIN verification
  - Check Balance: view balances after PIN verification
- Communication:
  - Uses axios for API calls to the gateway/backends
- State management:
  - Zustand used for centralized auth and account state (e.g., `authStore`, `accountStore`)
  - State persisted across sessions

## Current features implemented

- Authentication
  - Register user, login user, fetch user profile
  - HTTP-only cookie based session handling
  - Password hashing
- Transaction Service
  - Bank account creation
  - PIN-protected balance checks
  - Fund transfer with verification and single-payment flow
  - Idempotency and payment attempt tracking
- Frontend
  - Login / Logout
  - Dashboard with account details
  - Transfer Money page (with PIN verification)
  - Check Balance page (with PIN verification)
  - Error handling for unauthorized access
- Global state
  - Centralized auth and account state via Zustand
  - State persistence across browser sessions

## Database schema (high level)
- Users table (Auth service) — user credentials and profile
- Accounts table (Transaction service) — account number, owner, balance, PIN (store only secure, hashed/peppered PINs in production)
- transactions — transaction records (from, to, amount, timestamp, status, idempotency key)
- payment_attempts — logs of attempts for auditing and retry logic
- idempotency — keys and statuses to protect against duplicate operations

## Security & state management
- Sessions: HTTP-only cookies for improved XSS protection
- Credentials: passwords stored hashed (use a modern KDF like bcrypt/argon2 in production)
- PIN handling: PIN endpoints validate PINs before disclosing sensitive account info or authorizing transfers
- Idempotency: ensure uniqueness of operations to prevent duplicate money movements
- State: Zustand stores auth/account state on the frontend; sensitive flows guarded and validated server-side

## Technologies
- Frontend: React, CSS
- Backend: FastAPI (Python)
- Database: PostgreSQL
- State management: Zustand
- HTTP client: axios
- Security: HTTP-only cookies, hashed passwords

## Getting started

### Prerequisites
- Node.js (for frontend)
- Python 3.9+ (for backend services)
- PostgreSQL database
- Optional: Docker/Docker Compose (recommended for running multi-service stack)

### Environment variables (examples)
Create .env files for each service (examples — adapt to your implementation):

Auth service (.env)
- DATABASE_URL=postgresql://user:password@localhost:5432/auth_db
- SECRET_KEY=your_secret_key
- COOKIE_NAME=auth_session
- COOKIE_SECURE=false

Transaction service (.env)
- DATABASE_URL=postgresql://user:password@localhost:5432/tx_db
- PAYMENT_GATEWAY_URL=http://payment-gateway.local
- IDENTITY_SECRET=some_secret

Frontend (.env)
- REACT_APP_API_BASE_URL=http://localhost:8000/api

> Note: Use secure secrets in production and enable secure cookie flags (Secure, SameSite) and HTTPS.

### Running the services locally (high level)
1. Start PostgreSQL and create required databases (auth_db, tx_db) or use Docker Compose.
2. Backend (Auth & Transaction services)
   - Create virtual environment and install dependencies (pip install -r requirements.txt)
   - Apply migrations or create schemas in PostgreSQL
   - Start FastAPI services (e.g., uvicorn app.main:app --host 0.0.0.0 --port 8000)
3. API Gateway
   - Configure routes to point to the running backend services
   - Start gateway service (depends on implementation; could be FastAPI, Express, etc.)
4. Frontend
   - cd frontend
   - npm install
   - npm start (or yarn start)
5. Visit the frontend (e.g., http://localhost:3000) and register/login to use the app.

## Future plans
- Alert Service: send notifications for account activity and transaction updates (email/SMS/push)
- Analytics Service: track transaction metrics and generate insights (dashboards, reports)
- Enhance API Gateway: add logging, rate-limiting, authentication enforcement, monitoring, and observability
- Improve security hardening: rotate secrets, use OAuth2/JWT options for certain flows, strong PIN handling



## License
This repository's license information goes here — add a LICENSE file and reference it.
